type Vault @entity {
  id: ID!

  # Public Attributes
  initialized: Boolean!
  targetFloatPercent: BigInt
  feePercent: BigInt

  # Underlying
  underlying: Bytes! # address
  underlyingSymbol: String!
  underlyingDecimals: Int!
  underlyingIsWeth: Boolean!

  #Harvest data
  lastHarvestTimestamp: BigInt
  harvestWindow: BigInt
  harvestDelay: BigInt
  nextHarvestDelay: BigInt
  lastHarvestWindowStartTimestamp: BigInt

  # Strategies
  trustedStrategies: [Strategy!]! # trusted
  # strategies: [Strategy!]! # (computed): trusted and has balance

  # Holdings/Float/Supply
  maxLockedProfit: BigInt
  totalSupply: BigInt
  totalStrategyHoldings: BigInt

  lockedProfit: BigInt
  exchangeRate: BigInt
  totalFloat: BigInt
  totalHoldings: BigInt

  # Withdrawal Queue
  withdrawalQueue: [Strategy!]! 
}

### Important to derive and rely on from subgraph

# vault.withdrawalQueue: strategy[] ðŸš§
# vault.strategies: strategy[] // ?: trusted & balance >= 0
# vault.trustedStrategies: strategy[] âœ…

### Not important to rely on from subgraph - but will usually be synced

## Public Attributes
# vault.isInitialized: number âœ…
# vault.underlyingIsWETH: bool âœ…
# vault.targetFloatPercent: number âœ…
# vault.feePercent: number âœ…

## Harvest
# vault.lastHarvestTimestamp: number âœ…
# vault.harvestDelay: number âœ…
# vault.harvestWindow: number âœ…
# vault.lastHarvestWindowStartTimestamp: number âœ…
# vault.nextHarvestDelay: number âœ…

### Not important to rely on from subgraph - realtime data can be read from contracts

## Holdings/Float/Supply - call them via contracts and update

# vault.totalStrategyHoldings: number // view : gets updated on  StrategyDeposit âœ…, StrategyWithdraw âœ…,  SeizeStrategy âœ… and Harvest âœ…
# vault.totalSupply: number // view : gets updated on  Deposit  âœ… , Withdraw  âœ… , and Harvest âœ… (TODO: consider deriving this from Transfer)
# vault.maxLockedProfit: number // view: gets changed every Harvest âœ…

## Update these all the fuckin time - on StrategyDeposit âœ…, StrategyWithdraw âœ…, SeizeStrategy âœ… and Harvest âœ…, Deposit âœ… , Withdraw âœ… ,
# vault.lockedProfit: number // view: âœ…
# vault.exchangeRate: number // view: âœ…
# vault.totalFloat: number // view: âœ…
# vault.totalHoldings: number âœ…
  
## Note: might implement totalFees (read on the vault contract itself

### Save for Later
# vault.balanceOf{user} // don't implement rn
# vault.balanceOfUnderlying{user} // don't implement rn

type Strategy @entity {
  id: ID!

  # ERC20
  name: String!
  symbol: String!
  balance: BigInt!

  # Public Attributes
  trusted: Boolean!
  vault: Vault!
}

# strategy.trusted âœ…
# strategy.balance âœ…
# strategy.name  âœ…
# strategy.queueIndex (-1 or something if not in)
# strategy.vault (0x0 or something if no vault associated) âœ…
